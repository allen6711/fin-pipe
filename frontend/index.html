<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>FinPipe - Smart Accounting</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Retro Font: Roboto Mono -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Roboto+Mono:wght@400;500;700&display=swap" rel="stylesheet">
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    fontFamily: {
                        'sans': ['Roboto Mono', 'monospace'],
                    },
                    colors: {
                        'brand': {
                            'bg': '#f5f5dc', 'surface': '#ffffff', 'primary': '#d97706', 'primary-hover': '#b45309',
                            'secondary': '#047857', 'secondary-hover': '#065f46', 'text-primary': '#44403c',
                            'text-secondary': '#78716c', 'border': '#d6d3d1',
                        },
                    },
                    boxShadow: {
                        'retro': '4px 4px 0px 0px rgba(0,0,0,0.75)', 'retro-sm': '2px 2px 0px 0px rgba(0,0,0,0.75)',
                    }
                }
            }
        }
    </script>
    <style>
        body { -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale; background-color: #f5f5dc; }
        .modal-backdrop { background-color: rgba(0,0,0,0.5); }
        .btn-retro { transition: transform 0.1s ease-out, box-shadow 0.1s ease-out; }
        .btn-retro:active { transform: translate(2px, 2px); box-shadow: none !important; }
    </style>
</head>
<body class="bg-brand-bg font-sans text-brand-text-primary">

    <div id="root"></div>

    <!-- React and Babel -->
    <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    
    <!-- SheetJS for Excel parsing -->
    <script src="https://cdn.sheetjs.com/xlsx-latest/package/dist/xlsx.full.min.js"></script>
    
    <!-- Google API Libraries -->
    <script async defer src="https://apis.google.com/js/api.js"></script>
    <script async defer src="https://accounts.google.com/gsi/client"></script>

    <script type="text/babel">
        const { useState, useEffect, useCallback, useRef, memo } = React;

        // --- GLOBAL CONSTANTS ---
        const APP_DEFINED_FIELDS = { date: 'Date', description: 'Description', amount: 'Amount', category: 'Category', notes: 'Notes' };

        // --- SVG Icons (No Changes) --- //
        const UploadIcon = () => ( <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className="mx-auto h-12 w-12 text-brand-text-secondary"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path><polyline points="17 8 12 3 7 8"></polyline><line x1="12" y1="3" x2="12" y2="15"></line></svg> );
        const SettingsIcon = () => ( <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className="h-5 w-5"><path d="M12.22 2h-.44a2 2 0 0 0-2 2v.18a2 2 0 0 1-1 1.73l-.43.25a2 2 0 0 1-2 0l-.15-.08a2 2 0 0 0-2.73.73l-.22.38a2 2 0 0 0 .73 2.73l.15.1a2 2 0 0 1 0 2.4l-.15.08a2 2 0 0 0-.73 2.73l.22.38a2 2 0 0 0 2.73.73l.15-.08a2 2 0 0 1 2 0l.43.25a2 2 0 0 1 1 1.73V20a2 2 0 0 0 2 2h.44a2 2 0 0 0 2-2v-.18a2 2 0 0 1 1-1.73l.43-.25a2 2 0 0 1 2 0l.15.08a2 2 0 0 0 2.73-.73l-.22-.38a2 2 0 0 0-.73-2.73l-.15-.08a2 2 0 0 1 0-2.4l.15.08a2 2 0 0 0 .73-2.73l-.22-.38a2 2 0 0 0-2.73-.73l-.15.08a2 2 0 0 1-2 0l-.43-.25a2 2 0 0 1-1-1.73V4a2 2 0 0 0-2-2z"></path><circle cx="12" cy="12" r="3"></circle></svg> );
        const CloseIcon = () => ( <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className="h-6 w-6"><line x1="18" y1="6" x2="6" y2="18"></line><line x1="6" y1="6" x2="18" y2="18"></line></svg> );
        const Spinner = () => ( <svg className="animate-spin h-5 w-5 text-white" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24"><circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4"></circle><path className="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path></svg> );
        const ChevronDownIcon = () => (<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className="h-4 w-4"><path d="m6 9 6 6 6-6"/></svg>);

        // --- Child Components ---
        const CustomDropdown = ({ options, selectedValue, onChange }) => {
            const [isOpen, setIsOpen] = useState(false);
            const dropdownRef = useRef(null);

            const handleSelect = (option) => {
                onChange(option);
                setIsOpen(false);
            };

            useEffect(() => {
                const handleClickOutside = (event) => {
                    if (dropdownRef.current && !dropdownRef.current.contains(event.target)) {
                        setIsOpen(false);
                    }
                };
                document.addEventListener("mousedown", handleClickOutside);
                return () => document.removeEventListener("mousedown", handleClickOutside);
            }, [dropdownRef]);

            return (
                <div className="relative w-full" ref={dropdownRef}>
                    <button onClick={() => setIsOpen(!isOpen)} className="w-full flex justify-between items-center p-2 border-2 border-brand-border rounded-md bg-white">
                        <span>{selectedValue}</span>
                        <ChevronDownIcon />
                    </button>
                    {isOpen && (
                        <div className="absolute z-10 top-full mt-1 w-full bg-white border-2 border-brand-border rounded-md shadow-lg max-h-48 overflow-y-auto">
                            {options.map(option => (
                                <div key={option} onClick={() => handleSelect(option)} className="p-2 hover:bg-yellow-50 cursor-pointer">
                                    {option}
                                </div>
                            ))}
                        </div>
                    )}
                </div>
            );
        };
        
        const SettingsModal = ({ currentSettings, onClose, onSave }) => {
            const [settings, setSettings] = useState(currentSettings);

            const handleChange = (e) => {
                const { name, value } = e.target;
                setSettings(prev => ({ ...prev, [name]: value }));
            };

            const handleSave = () => {
                onSave(settings);
            };

            return (
                <div className="fixed inset-0 z-50 flex items-center justify-center modal-backdrop">
                    <div className="bg-brand-surface rounded-md border-2 border-brand-text-primary shadow-retro p-8 w-full max-w-lg relative">
                        <button onClick={onClose} className="absolute top-4 right-4 text-brand-text-secondary hover:text-brand-text-primary"><CloseIcon /></button>
                        <h2 className="text-2xl font-bold mb-6">API Settings</h2>
                        <div className="space-y-4">
                            <div>
                                <label className="block font-bold mb-1">Google Gemini API Key</label>
                                <input name="geminiKey" type="password" value={settings.geminiKey} onChange={handleChange} className="w-full p-2 border-2 border-brand-border rounded-md bg-white" placeholder="Paste your Gemini API Key here"/>
                            </div>
                            <div>
                                <label className="block font-bold mb-1">Google Sheets OAuth Client ID</label>
                                <input name="googleClientId" type="text" value={settings.googleClientId} onChange={handleChange} className="w-full p-2 border-2 border-brand-border rounded-md bg-white" placeholder="Paste your Client ID here"/>
                            </div>
                            <div>
                                <label className="block font-bold mb-1">Google Sheet ID</label>
                                <input name="sheetId" type="text" value={settings.sheetId} onChange={handleChange} className="w-full p-2 border-2 border-brand-border rounded-md bg-white" placeholder="Paste your Spreadsheet ID here"/>
                            </div>
                            <div>
                                <label className="block font-bold mb-1">Target Sheet Name (Tab Name)</label>
                                <input name="sheetName" type="text" value={settings.sheetName} onChange={handleChange} className="w-full p-2 border-2 border-brand-border rounded-md bg-white" placeholder="e.g., Transactions Log or 2024"/>
                            </div>
                        </div>
                        <div className="mt-8 flex justify-end">
                            <button onClick={handleSave} className="btn-retro px-6 py-2 bg-brand-primary text-white rounded-md font-bold hover:bg-brand-primary-hover shadow-retro-sm">Save & Close</button>
                        </div>
                    </div>
                </div>
            );
        };
        
        const MemoizedTableRow = memo(({ item, categories, onCategoryChange, onNoteChange, formatDisplayDate }) => {
            const dropdownOptions = [...categories];
            if (item.category === 'Error' && !dropdownOptions.includes('Error')) {
                dropdownOptions.push('Error');
            }
            
            return (
                <tr className="hover:bg-yellow-50">
                    <td className="p-3">{formatDisplayDate(item.date)}</td>
                    <td className="p-3">{item.description}</td>
                    <td className="p-3">{item.amount}</td>
                    <td className="p-3 relative">
                        <CustomDropdown 
                            options={dropdownOptions} 
                            selectedValue={item.category} 
                            onChange={(newCategory) => onCategoryChange(item.id, newCategory)} 
                        />
                    </td>
                    <td className="p-3"><input type="text" value={item.notes} onChange={(e) => onNoteChange(item.id, e.target.value)} className="w-full p-2 border-2 border-brand-border rounded-md bg-white"/></td>
                </tr>
            );
        });
        
        const FileUploadComponent = ({ onFileDrop }) => {
            const [isDragging, setIsDragging] = useState(false); 
            const inputRef = useRef(null);
            const handleDragEnter = (e) => { e.preventDefault(); e.stopPropagation(); setIsDragging(true); };
            const handleDragLeave = (e) => { e.preventDefault(); e.stopPropagation(); setIsDragging(false); };
            const handleDragOver = (e) => { e.preventDefault(); e.stopPropagation(); };
            const handleDrop = (e) => { 
                e.preventDefault(); 
                e.stopPropagation(); 
                setIsDragging(false); 
                if (e.dataTransfer.files?.length > 0) onFileDrop(e.dataTransfer.files); 
            };
            return ( <div className="text-center p-6 bg-brand-surface rounded-md border-2 border-brand-text-primary shadow-retro"> <input ref={inputRef} type="file" className="hidden" accept=".xlsx, .xls, .csv" onChange={(e) => onFileDrop(e.target.files)} /> <div onDragEnter={handleDragEnter} onDragLeave={handleDragLeave} onDragOver={handleDragOver} onDrop={handleDrop} className={`p-10 border-2 border-brand-border cursor-pointer transition-all duration-300 ${isDragging ? 'border-brand-primary bg-yellow-50' : 'border-dashed'}`}> <UploadIcon /> <p className="mt-4 text-lg font-bold">Drag & drop file here</p> <p className="text-brand-text-secondary my-2">or</p> <button onClick={() => inputRef.current.click()} className="btn-retro mt-2 px-6 py-2 bg-brand-primary text-white rounded-md font-bold hover:bg-brand-primary-hover shadow-retro-sm">Choose file</button> </div> </div> );
        };

        const Card = ({ title, subtitle, children }) => ( <div className="bg-brand-surface p-8 rounded-md border-2 border-brand-text-primary shadow-retro"> <h2 className="text-2xl font-bold mb-2">{title}</h2> <p className="text-brand-text-secondary mb-6">{subtitle}</p> {children} </div> );

        const ColumnMappingComponent = ({ headers, mappings, onMappingChange, onProcess, isLoading, isGoogleReady }) => ( <Card title="Step 2: Column Mapping" subtitle="Map Excel columns to application fields."><div className="space-y-4">{Object.keys(APP_DEFINED_FIELDS).filter(f => f !== 'category' && f !== 'notes').map(field => (<div key={field} className="grid grid-cols-1 md:grid-cols-2 gap-4 items-center"><label className="font-bold">{APP_DEFINED_FIELDS[field]}:</label><select value={mappings[field]} onChange={(e) => onMappingChange(field, e.target.value)} className="w-full p-2 border-2 border-brand-border rounded-md bg-white focus:ring-2 focus:ring-brand-primary focus:border-brand-primary"><option value="">Select Excel column</option>{headers.map(header => <option key={header} value={header}>{header}</option>)}</select></div>))}</div><div className="mt-8 flex justify-end"><button onClick={onProcess} disabled={isLoading || !isGoogleReady} className="btn-retro px-6 py-2 bg-brand-primary text-white rounded-md font-bold hover:bg-brand-primary-hover shadow-retro-sm flex items-center disabled:bg-gray-400 disabled:shadow-none">{isLoading && <Spinner />}<span className={isLoading ? 'ml-2' : ''}>Start Smart Categorization</span></button></div></Card> );
        
        const ReviewComponent = memo(({ data, categories, onCategoryChange, onNoteChange, onExport, onReset, formatDisplayDate, isLoading, tokenClient }) => ( <Card title="Step 3: Review & Export" subtitle="Review AI results, edit if needed, then export."><div className="overflow-x-auto max-h-[50vh] border-2 border-brand-border"><table className="w-full text-left table-auto"><thead className="sticky top-0 bg-brand-bg border-b-2 border-brand-text-primary"><tr><th className="p-3 font-bold">Date</th><th className="p-3 font-bold">Description</th><th className="p-3 font-bold">Amount</th><th className="p-3 font-bold w-48">Category</th><th className="p-3 font-bold w-64">Notes</th></tr></thead><tbody className="divide-y divide-brand-border bg-white">{data.map(item => ( <MemoizedTableRow key={item.id} item={item} categories={categories} onCategoryChange={onCategoryChange} onNoteChange={onNoteChange} formatDisplayDate={formatDisplayDate} /> ))}</tbody></table></div><div className="mt-8 flex justify-between items-center"><button onClick={onReset} className="font-bold hover:text-brand-primary">Start Over</button><button onClick={onExport} disabled={isLoading || !tokenClient} className="btn-retro px-6 py-2 bg-brand-secondary text-white rounded-md font-bold hover:bg-brand-secondary-hover shadow-retro-sm flex items-center disabled:bg-gray-400 disabled:shadow-none">{isLoading && <Spinner />}<span className={isLoading ? 'ml-2' : ''}>Authorize & Export</span></button></div></Card> ));


        // --- Main App Component ---
        function App() {
            // State variables
            const [step, setStep] = useState(1);
            const [file, setFile] = useState(null);
            const [headers, setHeaders] = useState([]);
            const [data, setData] = useState([]);
            const [mappings, setMappings] = useState({ date: '', description: '', amount: '' });
            const [processedData, setProcessedData] = useState([]);
            const [isLoading, setIsLoading] = useState(false);
            const [error, setError] = useState('');
            const [isSettingsOpen, setIsSettingsOpen] = useState(false);
            
            const [geminiKey, setGeminiKey] = useState('');
            const [googleClientId, setGoogleClientId] = useState('');
            const [sheetId, setSheetId] = useState('');
            const [sheetName, setSheetName] = useState('');
            
            const [tokenClient, setTokenClient] = useState(null);
            const [isGoogleReady, setIsGoogleReady] = useState(false);
            
            const [categories, setCategories] = useState(['Food', 'Clothing', 'Housing', 'Transport', 'Education', 'Entertainment', 'Investment', 'Medical', 'Income', 'Other']);
            const [payeeMappings, setPayeeMappings] = useState({});
            
            const processedDataRef = useRef(processedData);
            // **NEW**: Ref to store the callback for post-authorization action
            const postAuthAction = useRef(null);

            useEffect(() => {
                processedDataRef.current = processedData;
            }, [processedData]);

            useEffect(() => {
                const interval = setInterval(() => {
                    if (window.gapi && window.google) {
                        clearInterval(interval);
                        setIsGoogleReady(true);
                    }
                }, 100);
                return () => clearInterval(interval);
            }, []);
            
            useEffect(() => {
                if (!isGoogleReady) return; 

                setGeminiKey(localStorage.getItem('geminiKey') || '');
                const clientId = localStorage.getItem('googleClientId') || '';
                setGoogleClientId(clientId);
                setSheetId(localStorage.getItem('sheetId') || '');
                setSheetName(localStorage.getItem('sheetName') || '');
                const savedMappings = localStorage.getItem('columnMappings');
                if (savedMappings) { setMappings(JSON.parse(savedMappings)); }
                const savedPayeeMappings = localStorage.getItem('payeeMappings');
                if(savedPayeeMappings) { setPayeeMappings(JSON.parse(savedPayeeMappings)); }

                gapi.load('client', () => {
                    gapi.client.load('sheets', 'v4', () => {
                        console.log("GAPI client for Sheets loaded.");
                    });
                });

                if (clientId) {
                    const client = google.accounts.oauth2.initTokenClient({
                        client_id: clientId,
                        scope: 'https://www.googleapis.com/auth/spreadsheets',
                        callback: (tokenResponse) => {
                            if (tokenResponse && tokenResponse.access_token) {
                                gapi.client.setToken(tokenResponse);
                                // **MODIFIED**: Execute the stored action after auth
                                if (postAuthAction.current) {
                                    postAuthAction.current();
                                    postAuthAction.current = null; // Clear after use
                                }
                            }
                        },
                    });
                    setTokenClient(client);
                }
            }, [isGoogleReady, googleClientId]);
            
            const handleFileDrop = useCallback((acceptedFiles) => {
                const selectedFile = acceptedFiles[0];
                if (selectedFile) {
                    setError('');
                    const reader = new FileReader();
                    reader.onload = (e) => {
                        try {
                            const workbook = XLSX.read(new Uint8Array(e.target.result), { type: 'array' });
                            const worksheet = workbook.Sheets[workbook.SheetNames[0]];
                            const json = XLSX.utils.sheet_to_json(worksheet, { header: 1, cellDates: true });
                            if (json.length > 0) {
                                setHeaders(json[0]); setData(json.slice(1)); setStep(2);
                            } else { setError('The Excel file is empty or incorrectly formatted.'); }
                        } catch (err) { setError('Failed to parse the file. Please ensure it is a .xlsx or .csv file.'); }
                    };
                    reader.readAsArrayBuffer(selectedFile);
                }
            }, []);
            
            const fetchCategoriesFromSheet = async () => {
                if (!sheetId) {
                    console.warn("Sheet ID not set, using default categories.");
                    return Promise.resolve();
                }
                if (!gapi.client.getToken()) {
                    console.warn("Not authorized to fetch categories yet.");
                    return new Promise((resolve) => {
                        postAuthAction.current = () => fetchCategoriesFromSheet().then(resolve);
                        tokenClient.requestAccessToken();
                    });
                }
                try {
                    const response = await gapi.client.sheets.spreadsheets.values.batchGet({
                        spreadsheetId: sheetId,
                        ranges: ['Summary!B28:B50', 'Summary!H28:H50'], 
                    });
                    const valueRanges = response.result.valueRanges;
                    let fetchedCategories = [];
                    if (valueRanges && valueRanges.length > 0) {
                        valueRanges.forEach(range => {
                            if (range.values) {
                                range.values.forEach(row => {
                                    if (row[0]) fetchedCategories.push(row[0]);
                                });
                            }
                        });
                    }
                    if (fetchedCategories.length > 0) {
                        const uniqueCategories = [...new Set(fetchedCategories)];
                        setCategories(uniqueCategories);
                        console.log("Fetched categories:", uniqueCategories);
                    } else {
                        console.warn("No categories found in 'Summary' sheet, using default list.");
                    }
                } catch (err) {
                    console.error("Error fetching categories:", err);
                    setError("Could not fetch categories from 'Summary' sheet. Check permissions and sheet name.");
                }
            };
            
            const handleMappingChange = (appField, excelHeader) => { setMappings(prev => ({ ...prev, [appField]: excelHeader })); };

            const processData = async () => {
                if (!mappings.date || !mappings.description || !mappings.amount) {
                    setError('Please map all required fields: Date, Description, and Amount.'); return;
                }
                
                await fetchCategoriesFromSheet();

                if (!geminiKey) {
                    setError('Please enter your Google Gemini API Key in the settings first.'); setIsSettingsOpen(true); return;
                }
                localStorage.setItem('columnMappings', JSON.stringify(mappings));
                setError(''); setIsLoading(true);
                const dateIndex = headers.indexOf(mappings.date);
                const descIndex = headers.indexOf(mappings.description);
                const amountIndex = headers.indexOf(mappings.amount);
                
                const itemsToCategorizeWithAI = [];
                const preCategorizedItems = [];

                data.forEach((row, index) => {
                    const description = row[descIndex];
                    const item = {
                        id: index, date: row[dateIndex], description: description,
                        amount: row[amountIndex], category: '', notes: ''
                    };
                    if (description && item.amount) {
                        if (payeeMappings[description]) {
                            item.category = payeeMappings[description];
                            preCategorizedItems.push(item);
                        } else {
                            itemsToCategorizeWithAI.push(item);
                        }
                    }
                });
                
                try {
                    const aiCategorizedItems = await categorizeWithAI(itemsToCategorizeWithAI);
                    const allProcessedData = [...preCategorizedItems, ...aiCategorizedItems].sort((a, b) => a.id - b.id);
                    setProcessedData(allProcessedData);
                    setStep(3);
                } catch(err) {
                    setError(`AI categorization failed: ${err.message}`);
                } finally { setIsLoading(false); }
            };
            
            const categorizeWithAI = async (items) => {
                if (items.length === 0) return [];

                console.log(`Sending ${items.length} items to AI for batch categorization...`);

                const API_URL = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-05-20:generateContent?key=${geminiKey}`;
                
                const descriptions = items.map(item => `"${item.description}"`).join('\n');
                
                const systemPrompt = `You are a strict data classification engine. Your ONLY function is to assign a category to a given transaction description from a predefined list.

                **Rules:**
                1.  You MUST choose a category from the 'Valid Categories' list provided below.
                2.  You are FORBIDDEN from inventing or using any category name that is NOT on this list.
                3.  Analyze the description and find the BEST possible match from the list.
                4.  If no category is a clear and direct match, you MUST use the category 'Other'.

                Valid Categories: ${categories.join(', ')}

                Respond with a valid JSON array of objects, where each object has two keys: "description" and "category". The "description" must exactly match one of the input descriptions. Do not add any extra text, explanations, or markdown formatting around the JSON response.`;

                const userQuery = `Please categorize the following transactions:\n${descriptions}`;
                
                try {
                    const response = await fetch(API_URL, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            contents: [{ parts: [{ text: userQuery }] }],
                            systemInstruction: { parts: [{ text: systemPrompt }] },
                            generationConfig: { responseMimeType: "application/json" }
                        })
                    });

                    if (!response.ok) {
                       const errorBody = await response.json();
                       const errorMessage = errorBody.error?.message || response.statusText;
                       if (response.status === 429 || response.status === 503 || errorMessage.toLowerCase().includes('overloaded')) {
                           throw new Error('Retriable error');
                       }
                       throw new Error(`API request failed: ${errorMessage}`);
                    }

                    const result = await response.json();
                    const jsonString = result.candidates?.[0]?.content?.parts?.[0]?.text;
                    const categorizedResults = JSON.parse(jsonString);

                    const categoryMap = new Map(categorizedResults.map(res => [res.description, res.category]));

                    return items.map(item => {
                        const foundCategory = categoryMap.get(item.description);
                        item.category = categories.includes(foundCategory) ? foundCategory : 'Other';
                        return item;
                    });

                } catch (err) {
                    if (err.message === 'Retriable error') {
                        console.warn("Model is busy or rate-limited, retrying batch in 2 seconds...");
                        await new Promise(resolve => setTimeout(resolve, 2000));
                        return categorizeWithAI(items); // Retry the whole batch
                    }
                    console.error("AI Batch Processing Error:", err);
                    return items.map(item => {
                        item.category = 'Error';
                        return item;
                    });
                }
            };

            const handleCategoryChange = useCallback((id, newCategory) => {
                setProcessedData(prevData => prevData.map(item => {
                    if (item.id === id) {
                        if(item.description){
                            const newPayeeMappings = {...payeeMappings, [item.description]: newCategory};
                            setPayeeMappings(newPayeeMappings);
                            localStorage.setItem('payeeMappings', JSON.stringify(newPayeeMappings));
                        }
                        return { ...item, category: newCategory };
                    }
                    return item;
                }));
            }, [payeeMappings]);
            
            const handleNoteChange = useCallback((id, newNote) => {
                setProcessedData(prevData => prevData.map(item => item.id === id ? { ...item, notes: newNote } : item));
            }, []);

            const handleGoogleAuth = useCallback(() => {
                setError('');
                if (!googleClientId) { setError('Please set your Google Client ID in the settings.'); setIsSettingsOpen(true); return; }
                if (tokenClient) { 
                    // Set the action to be exportToSheet after successful auth
                    postAuthAction.current = exportToSheet;
                    tokenClient.requestAccessToken(); 
                } 
                else { setError("Google Auth client is not ready. Please check your Client ID and refresh."); }
            }, [googleClientId, tokenClient]);
            
            const formatExportDate = (date) => {
                if (date instanceof Date && !isNaN(date)) {
                    return date.toLocaleDateString('sv-SE'); // YYYY-MM-DD
                }
                if (typeof date === 'number') {
                    const jsDate = new Date((date - 25569) * 86400 * 1000);
                    return jsDate.toLocaleDateString('sv-SE');
                }
                return date;
            };
            
            const exportToSheet = async () => {
                if (!sheetId || !sheetName) { setError('Please provide a Google Sheet ID and Target Sheet Name in the settings.'); setIsSettingsOpen(true); return; }
                setIsLoading(true); setError('');
                
                try {
                    const allData = processedDataRef.current;
                    const expenses = allData.filter(item => parseFloat(item.amount) < 0);
                    const income = allData.filter(item => parseFloat(item.amount) >= 0);

                    const formatData = (data, isExpense) => data.map(item => {
                        const amount = parseFloat(item.amount);
                        return [ formatExportDate(item.date), isExpense ? Math.abs(amount) : amount, item.description, item.category, item.notes || '' ];
                    });

                    const expensesValues = formatData(expenses, true);
                    const incomeValues = formatData(income, false);
                    const requests = [];

                    if (expensesValues.length > 0) {
                        console.log("Attempting to export EXPENSES:", expensesValues);
                        requests.push(gapi.client.sheets.spreadsheets.values.append({
                            spreadsheetId: sheetId, range: `'${sheetName}'!B5`,
                            valueInputOption: 'USER_ENTERED', resource: { values: expensesValues },
                        }));
                    }

                    if (incomeValues.length > 0) {
                        console.log("Attempting to export INCOME:", incomeValues);
                        requests.push(gapi.client.sheets.spreadsheets.values.append({
                            spreadsheetId: sheetId, range: `'${sheetName}'!H5`,
                            valueInputOption: 'USER_ENTERED', resource: { values: incomeValues },
                        }));
                    }
                    
                    if (requests.length > 0) {
                        await Promise.all(requests);
                        console.log("Google Sheets API success response for all requests.");
                        alert('Data successfully exported to Google Sheet!');
                        resetState();
                    } else { setError("No data to export."); }

                } catch (err) { 
                    console.error("Google Sheets API Error:", err);
                    setError(`Export failed: ${err.result?.error?.message || 'Check the console (F12) for detailed error information.'}`);
                } finally { setIsLoading(false); }
            };

            const resetState = useCallback(() => {
                setStep(1); setFile(null); setHeaders([]); setData([]); setProcessedData([]); setError('');
            }, []);
            
            const formatDisplayDate = useCallback((date) => {
                if (date instanceof Date && !isNaN(date)) {
                    return date.toLocaleDateString(); // MM/DD/YYYY format
                }
                if (typeof date === 'number') {
                    const jsDate = new Date((date - 25569) * 86400 * 1000);
                    return jsDate.toLocaleDateString();
                }
                return String(date); 
            }, []);

            if (!isGoogleReady) {
                return <div className="flex items-center justify-center h-screen"><p className="text-xl font-bold">Loading Scripts...</p></div>;
            }

            return (
                <div className="min-h-screen p-4 sm:p-6 md:p-8 flex flex-col items-center">
                    <header className="w-full max-w-4xl flex justify-between items-center mb-8">
                        <h1 className="text-3xl sm:text-4xl font-bold">FinPipe</h1>
                        <button onClick={() => setIsSettingsOpen(true)} className="p-2 rounded-full hover:bg-black/10 transition-colors" title="Settings"><SettingsIcon /></button>
                    </header>
                    <main className="w-full max-w-4xl">
                        {error && <div className="bg-red-200 border-2 border-red-800 text-red-900 px-4 py-3 rounded-md relative mb-6 font-bold" role="alert">{error}</div>}
                        {step === 1 && <FileUploadComponent onFileDrop={handleFileDrop} />}
                        {step === 2 && <ColumnMappingComponent headers={headers} mappings={mappings} onMappingChange={handleMappingChange} onProcess={processData} isLoading={isLoading} isGoogleReady={isGoogleReady} />}
                        {step === 3 && <ReviewComponent data={processedData} categories={categories} onCategoryChange={handleCategoryChange} onNoteChange={handleNoteChange} onExport={handleGoogleAuth} onReset={resetState} formatDisplayDate={formatDisplayDate} isLoading={isLoading} tokenClient={tokenClient}/>}
                    </main>
                    {isSettingsOpen && <SettingsModal 
                        currentSettings={{ geminiKey, googleClientId, sheetId, sheetName }}
                        onClose={() => setIsSettingsOpen(false)} 
                        onSave={(newSettings) => {
                            setGeminiKey(newSettings.geminiKey);
                            setGoogleClientId(newSettings.googleClientId);
                            setSheetId(newSettings.sheetId);
                            setSheetName(newSettings.sheetName);
                            localStorage.setItem('geminiKey', newSettings.geminiKey);
                            localStorage.setItem('googleClientId', newSettings.googleClientId);
                            localStorage.setItem('sheetId', newSettings.sheetId);
                            localStorage.setItem('sheetName', newSettings.sheetName);
                            setIsSettingsOpen(false);
                        }} 
                    />}
                </div>
            );
        }
        
        const container = document.getElementById('root');
        const root = ReactDOM.createRoot(container);
        root.render(<App />);
    </script>

</body>
</html>

